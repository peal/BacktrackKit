# BacktrackKit, chapter 8
#
# DO NOT EDIT THIS FILE - EDIT EXAMPLES IN THE SOURCE INSTEAD!
#
# This file has been generated by AutoDoc. It contains examples extracted from
# the package documentation. Each example is preceded by a comment which gives
# the name of a GAPDoc XML file and a line range from which the example were
# taken. Note that the XML file in turn may have been generated by AutoDoc
# from some other input.
#
gap> START_TEST("backtrackkit08.tst");

# doc/_Chapter_Tutorial.xml:25-29
gap> LoadPackage("BacktrackKit", false);;
gap> p := PartitionStack(8);
[ [ 1, 2, 3, 4, 5, 6, 7, 8 ] ]

# doc/_Chapter_Tutorial.xml:35-37
gap> t := RecordingTracer();;

# doc/_Chapter_Tutorial.xml:43-47
gap> PS_SplitCellsByFunction(p, t, {x} -> x mod 3);;
gap> p;
[ [ 3, 6 ], [ 2, 5, 8 ], [ 1, 4, 7 ] ]

# doc/_Chapter_Tutorial.xml:53-57
gap> PS_SplitCellsByFunction(p, t, {x} -> x mod 2);;
gap> p;
[ [ 6 ], [ 2, 8 ], [ 4 ], [ 3 ], [ 5 ], [ 1, 7 ] ]

# doc/_Chapter_Tutorial.xml:65-80
gap> # Number of cells
> PS_Cells(p);
6
gap> # Cells of size 1, in the order they were created
> PS_FixedCells(p);
[ 1, 4, 5, 3 ]
gap> # Contents of the cells of size 1
> PS_FixedPoints(p);
[ 6, 3, 5, 4 ]
gap> # The contents of a cell, as a slice (a type of list)
> PS_CellSlice(p, 2);
<slice size=2>
gap> AsList(last);
[ 2, 8 ]

# doc/_Chapter_Tutorial.xml:88-97
gap> PS_RevertToCellCount(p, 3);
gap> p;
[ [ 3, 6 ], [ 2, 5, 8 ], [ 1, 4, 7 ] ]
gap> PS_RevertToCellCount(p, 2);
gap> p;
[ [ 1, 3, 4, 6, 7 ], [ 2, 5, 8 ] ]
gap> AsList(PS_CellSlice(p, 1));
[ 6, 3, 4, 1, 7 ]

# doc/_Chapter_Tutorial.xml:113-126
gap> LoadPackage("BacktrackKit", false);;
gap> G := Group((1,2,3),(4,5,6),(1,4)(2,5)(3,6));;
gap> H := Group((1,2,3,4,5,6),(2,3)(4,5));;
gap> # Need to make a partition stack to search over
> ps := PartitionStack(6);;
gap> # We create a refiner for each group
> # We have to give this how many points we want the group to act on
> rg := BTKit_Con.InGroup(G);;
gap> rh := BTKit_Con.InGroup(H);;
gap> # Finally, intersect the groups
> BTKit_SimpleSearch(ps, [rg, rh]);
Group([ (1,2,3)(4,6,5), (1,4)(2,5)(3,6) ])

# doc/_Chapter_Tutorial.xml:132-144
gap> # This represents the group which stabilizes the set [3,4,5,6]
> ss := BTKit_Con.SetStab([3,4,5,6]);;
gap> # We can prove this by just "searching" on this group
> BTKit_SimpleSearch(ps, [ss]);
Group([ (5,6), (4,5), (3,4), (1,2) ])
gap> # We can intersect this with G
> BTKit_SimpleSearch(ps, [rg,ss]);
Group([ (4,5,6) ])
gap> # We can also intersect G and H and the set stabilizer at the same time!
> BTKit_SimpleSearch(ps, [rg,rh,ss]);
Group(())

#
gap> STOP_TEST("backtrackkit08.tst", 1);
